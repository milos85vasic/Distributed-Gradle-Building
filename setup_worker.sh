#!/bin/bash

set -e

PROJECT_DIR="$1"

if [[ -z "$PROJECT_DIR" ]]; then
  echo "Usage: $0 <project_directory>"
  exit 1
fi

PROJECT_DIR=$(realpath "$PROJECT_DIR")

echo "üîß Distributed Gradle Build - Worker Setup"
echo "========================================"
echo ""
echo "This script prepares a worker machine for distributed building"
echo "that will utilize its CPU and memory for Gradle tasks."
echo ""

read -p "Enter master IP address: " MASTER_IP
echo ""
echo "Setting up worker for distributed builds with master: $MASTER_IP"
echo ""

# Install required packages
echo "üì¶ Installing required packages..."
sudo apt update
sudo apt install -y rsync openjdk-17-jdk jq curl htop

# Detect worker resources
echo "üñ•Ô∏è  Detecting worker resources..."
WORKER_CORES=$(nproc --all)
WORKER_MEMORY_GB=$(free -g | awk '/^Mem:/{print $2}')
WORKER_DISK_GB=$(df -BG . | tail -1 | awk '{print $4}' | sed 's/G//')

echo "   CPU Cores: $WORKER_CORES"
echo "   Memory: ${WORKER_MEMORY_GB}GB"
echo "   Available Disk: ${WORKER_DISK_GB}GB"
echo ""

# Create worker directories
echo "üìÅ Creating worker directories..."
mkdir -p "$PROJECT_DIR"
mkdir -p "$PROJECT_DIR/.distributed/{logs,cache,metrics}"
mkdir -p "$PROJECT_DIR/.gradle"

echo "   Project: $PROJECT_DIR"
echo "   Distributed logs: $PROJECT_DIR/.distributed/logs"
echo "   Distributed cache: $PROJECT_DIR/.distributed/cache"
echo ""

# Test SSH connectivity to master
echo "üîó Testing SSH connectivity to master..."
if ! ssh -o BatchMode=yes -o ConnectTimeout=5 "$MASTER_IP" echo "OK" >/dev/null 2>&1; then
    echo "‚ùå Error: SSH to master $MASTER_IP failed."
    echo "üí° Setup passwordless SSH with: ssh-copy-id $MASTER_IP"
    echo "   Or run: ./setup_passwordless_ssh.sh"
    exit 1
else
    echo "‚úÖ SSH to master $MASTER_IP: OK"
fi
echo ""

# Create worker environment file
WORKER_ENV="$PROJECT_DIR/.distributed/worker.env"
cat <<EOF > "$WORKER_ENV"
# Distributed Gradle Build Worker Configuration
# Generated by setup_worker.sh on $(date)
export WORKER_ID="\$(hostname)-\$(date +%s)"
export MASTER_IP="$MASTER_IP"
export PROJECT_DIR="$PROJECT_DIR"
export WORKER_CORES="$WORKER_CORES"
export WORKER_MEMORY_GB="$WORKER_MEMORY_GB"
export WORKER_AVAILABLE_DISK_GB="$WORKER_DISK_GB"
export WORKER_READY=true
EOF

echo "‚öôÔ∏è  Worker configuration created: $WORKER_ENV"
echo ""

# Create worker status script
WORKER_STATUS_SCRIPT="$PROJECT_DIR/.distributed/worker_status.sh"
cat <<'EOF' > "$WORKER_STATUS_SCRIPT"
#!/bin/bash

# Worker status reporting for distributed builds
source "$(dirname "$0")/worker.env"

# Current resource usage
CPU_LOAD=$(uptime | awk -F'load average:' '{print $2}' | awk '{print $1}' | sed 's/,//')
MEMORY_USED_GB=$(free -g | awk '/^Mem:/{print $3}')
MEMORY_PCT=$((MEMORY_USED_GB * 100 / WORKER_MEMORY_GB))
DISK_USED_GB=$(df -BG . | tail -1 | awk '{print $3}' | sed 's/G//')
DISK_PCT=$((DISK_USED_GB * 100 / WORKER_AVAILABLE_DISK_GB))

cat <<STATUS
{
  "worker_id": "$WORKER_ID",
  "master_ip": "$MASTER_IP",
  "cpu_cores": $WORKER_CORES,
  "cpu_load": $CPU_LOAD,
  "memory_total_gb": $WORKER_MEMORY_GB,
  "memory_used_gb": $MEMORY_USED_GB,
  "memory_usage_pct": $MEMORY_PCT,
  "disk_total_gb": $WORKER_AVAILABLE_DISK_GB,
  "disk_used_gb": $DISK_USED_GB,
  "disk_usage_pct": $DISK_PCT,
  "ready": $WORKER_READY,
  "timestamp": $(date +%s)
}
STATUS
EOF

chmod +x "$WORKER_STATUS_SCRIPT"
echo "‚úÖ Worker status script created: $WORKER_STATUS_SCRIPT"
echo ""

# Create worker health monitor
WORKER_MONITOR_SCRIPT="$PROJECT_DIR/.distributed/worker_monitor.sh"
cat <<'EOF' > "$WORKER_MONITOR_SCRIPT"
#!/bin/bash

# Worker health monitor for distributed builds
source "$(dirname "$0")/worker.env"

LOG_FILE="$(dirname "$0")/logs/worker_monitor.log"
METRICS_FILE="$(dirname "$0")/metrics/worker_metrics.json"

mkdir -p "$(dirname "$LOG_FILE")" "$(dirname "$METRICS_FILE")"

while true; do
    # Get current status
    STATUS="$($(dirname "$0")/worker_status.sh)"
    
    # Log to file
    echo "$(date '+%Y-%m-%d %H:%M:%S') - $STATUS" >> "$LOG_FILE"
    
    # Update metrics JSON
    echo "$STATUS" > "$METRICS_FILE"
    
    # Sleep for monitoring interval
    sleep 30
done &
echo $! > "$(dirname "$0")/worker_monitor.pid"
EOF

chmod +x "$WORKER_MONITOR_SCRIPT"
echo "‚úÖ Worker monitor script created: $WORKER_MONITOR_SCRIPT"
echo ""

# Start worker monitor
echo "üöÄ Starting worker health monitor..."
"$WORKER_MONITOR_SCRIPT"
MONITOR_PID=$(cat "$PROJECT_DIR/.distributed/worker_monitor.pid")
echo "   Monitor started with PID: $MONITOR_PID"
echo ""

echo "üéØ WORKER SETUP COMPLETE"
echo "========================="
echo ""
echo "Worker Configuration Summary:"
echo "  Worker ID: $(hostname)-$(date +%s)"
echo "  Master: $MASTER_IP"
echo "  CPU Cores: $WORKER_CORES"
echo "  Memory: ${WORKER_MEMORY_GB}GB"
echo "  Project Directory: $PROJECT_DIR"
echo ""
echo "Services Started:"
echo "  Health Monitor: PID $MONITOR_PID"
echo "  Status Script: $WORKER_STATUS_SCRIPT"
echo ""
echo "This worker is now ready for distributed builds and will"
echo "contribute its CPU and memory to Gradle build tasks."
echo ""
echo "To stop monitoring: kill $MONITOR_PID"
echo "To check status: $WORKER_STATUS_SCRIPT"
echo ""
